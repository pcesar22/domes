#pragma once

/**
 * @file traceEvent.hpp
 * @brief Trace event structures and enums for performance profiling
 *
 * Defines a compact 16-byte trace event format suitable for ring buffer
 * storage on embedded systems. Events can be converted to Chrome Trace
 * Format (JSON) for visualization in Perfetto or Chrome tracing.
 */

#include <cstdint>

namespace domes::trace {

/**
 * @brief Categories for trace events
 *
 * Used to filter and color-code events in trace visualization.
 * Stored in upper 4 bits of TraceEvent::flags.
 */
enum class TraceCategory : uint8_t {
    kKernel = 0,     ///< FreeRTOS kernel events (task switch, ISR)
    kTransport = 1,  ///< USB/BLE transport operations
    kOta = 2,        ///< OTA update operations
    kWifi = 3,       ///< WiFi/ESP-NOW operations
    kLed = 4,        ///< LED animations
    kAudio = 5,      ///< Audio playback
    kTouch = 6,      ///< Touch sensing
    kGame = 7,       ///< Game logic
    kUser = 8,       ///< User-defined events
    kHaptic = 9,     ///< Haptic feedback
    kBle = 10,       ///< BLE operations
    kNvs = 11,       ///< NVS storage operations
};

/**
 * @brief Types of trace events
 *
 * Kernel events (0x01-0x0F) are generated by FreeRTOS hooks.
 * Application events (0x20-0x2F) are generated by user code.
 */
enum class TraceEventType : uint8_t {
    // FreeRTOS kernel events (0x01-0x0F)
    kTaskSwitchIn = 0x01,   ///< Task switched in (began running)
    kTaskSwitchOut = 0x02,  ///< Task switched out (stopped running)
    kTaskCreate = 0x03,     ///< Task created
    kTaskDelete = 0x04,     ///< Task deleted
    kIsrEnter = 0x05,       ///< ISR entered
    kIsrExit = 0x06,        ///< ISR exited
    kQueueSend = 0x07,      ///< Queue send operation
    kQueueReceive = 0x08,   ///< Queue receive operation
    kMutexLock = 0x09,      ///< Mutex acquired
    kMutexUnlock = 0x0A,    ///< Mutex released

    // Application events (0x20-0x2F)
    kSpanBegin = 0x20,  ///< Begin of a duration span
    kSpanEnd = 0x21,    ///< End of a duration span
    kInstant = 0x22,    ///< Instant/point event
    kCounter = 0x23,    ///< Counter value update
    kComplete = 0x24,   ///< Complete event (has duration in arg2)
};

/**
 * @brief Compact trace event structure (16 bytes)
 *
 * Designed for efficient storage in a ring buffer:
 * - Fixed size enables simple buffer arithmetic
 * - No pointers or strings (uses IDs that map to names on host)
 * - Packed to minimize memory footprint
 *
 * @note This struct is packed and should not be used for alignment-sensitive
 *       operations. Always use memcpy when moving between aligned buffers.
 */
#pragma pack(push, 1)
struct TraceEvent {
    uint32_t timestamp;  ///< Microseconds since boot (esp_timer_get_time())
    uint16_t taskId;     ///< FreeRTOS task number (uxTaskGetTaskNumber())
    uint8_t eventType;   ///< TraceEventType value
    uint8_t flags;       ///< Category in bits 7-4, reserved in bits 3-0
    uint32_t arg1;       ///< Primary argument (span ID, counter ID, ISR number)
    uint32_t arg2;       ///< Secondary argument (counter value, duration)

    /// Extract category from flags
    TraceCategory category() const { return static_cast<TraceCategory>((flags >> 4) & 0x0F); }

    /// Set category in flags
    void setCategory(TraceCategory cat) {
        flags = (flags & 0x0F) | (static_cast<uint8_t>(cat) << 4);
    }

    /// Get event type as enum
    TraceEventType type() const { return static_cast<TraceEventType>(eventType); }
};
#pragma pack(pop)

static_assert(sizeof(TraceEvent) == 16, "TraceEvent must be exactly 16 bytes");

/**
 * @brief Category names for trace output
 *
 * Used by host-side tools to convert category enum to string.
 */
constexpr const char* kCategoryNames[] = {
    "kernel",     // 0
    "transport",  // 1
    "ota",        // 2
    "wifi",       // 3
    "led",        // 4
    "audio",      // 5
    "touch",      // 6
    "game",       // 7
    "user",       // 8
    "haptic",     // 9
    "ble",        // 10
    "nvs",        // 11
};

}  // namespace domes::trace
