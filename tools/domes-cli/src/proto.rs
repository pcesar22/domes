//! Protocol Buffer generated types
//!
//! This module includes code generated from firmware/common/proto/*.proto
//! DO NOT manually define protocol types - they are generated by prost.
//!
//! To add new messages or modify existing ones:
//! 1. Edit firmware/common/proto/*.proto
//! 2. Run `cargo build` - prost will regenerate this code
//! 3. Update code that uses the types

/// Config protocol types (generated from config.proto)
#[allow(dead_code)]
pub mod config {
    include!(concat!(env!("OUT_DIR"), "/domes.config.rs"));

    impl Feature {
        /// Get user-friendly name for CLI display
        pub fn cli_name(&self) -> &'static str {
            match self {
                Feature::Unknown => "unknown",
                Feature::LedEffects => "led-effects",
                Feature::BleAdvertising => "ble",
                Feature::Wifi => "wifi",
                Feature::EspNow => "esp-now",
                Feature::Touch => "touch",
                Feature::Haptic => "haptic",
                Feature::Audio => "audio",
            }
        }

        /// Parse from CLI input string
        pub fn from_cli_name(s: &str) -> Option<Feature> {
            match s.to_lowercase().as_str() {
                "led-effects" | "led" | "leds" => Some(Feature::LedEffects),
                "ble" | "bluetooth" | "ble-advertising" => Some(Feature::BleAdvertising),
                "wifi" | "wi-fi" => Some(Feature::Wifi),
                "esp-now" | "espnow" => Some(Feature::EspNow),
                "touch" => Some(Feature::Touch),
                "haptic" | "haptics" => Some(Feature::Haptic),
                "audio" | "sound" => Some(Feature::Audio),
                _ => None,
            }
        }
    }

    impl std::fmt::Display for Feature {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.cli_name())
        }
    }

    impl std::str::FromStr for Feature {
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            Self::from_cli_name(s).ok_or_else(|| format!("Unknown feature: {}", s))
        }
    }

    impl MsgType {
        /// Convert to u8 for frame encoding
        pub fn as_u8(&self) -> u8 {
            *self as i32 as u8
        }
    }

    impl SystemMode {
        /// Get user-friendly name for CLI display
        pub fn cli_name(&self) -> &'static str {
            match self {
                SystemMode::Booting => "booting",
                SystemMode::Idle => "idle",
                SystemMode::Triage => "triage",
                SystemMode::Connected => "connected",
                SystemMode::Game => "game",
                SystemMode::Error => "error",
            }
        }

        /// Parse from CLI input string
        pub fn from_cli_name(s: &str) -> Option<SystemMode> {
            match s.to_lowercase().as_str() {
                "booting" => Some(SystemMode::Booting),
                "idle" => Some(SystemMode::Idle),
                "triage" => Some(SystemMode::Triage),
                "connected" => Some(SystemMode::Connected),
                "game" => Some(SystemMode::Game),
                "error" => Some(SystemMode::Error),
                _ => None,
            }
        }
    }

    impl std::fmt::Display for SystemMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.cli_name())
        }
    }

    impl std::str::FromStr for SystemMode {
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            Self::from_cli_name(s).ok_or_else(|| format!("Unknown mode: {}", s))
        }
    }
}

/// Trace protocol types (generated from trace.proto)
#[allow(dead_code)]
pub mod trace {
    include!(concat!(env!("OUT_DIR"), "/domes.trace.rs"));

    impl MsgType {
        /// Convert to u8 for frame encoding
        pub fn as_u8(&self) -> u8 {
            *self as i32 as u8
        }
    }

    impl Status {
        /// Get human-readable name for CLI display
        pub fn cli_name(&self) -> &'static str {
            match self {
                Status::Ok => "ok",
                Status::NotInit => "not-initialized",
                Status::AlreadyOn => "already-on",
                Status::AlreadyOff => "already-off",
                Status::BufferEmpty => "buffer-empty",
                Status::Error => "error",
            }
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.cli_name())
        }
    }

    impl Category {
        /// Get human-readable name for CLI display
        pub fn cli_name(&self) -> &'static str {
            match self {
                Category::Kernel => "kernel",
                Category::Transport => "transport",
                Category::Ota => "ota",
                Category::Wifi => "wifi",
                Category::Led => "led",
                Category::Audio => "audio",
                Category::Touch => "touch",
                Category::Game => "game",
                Category::User => "user",
                Category::Haptic => "haptic",
                Category::Ble => "ble",
                Category::Nvs => "nvs",
            }
        }
    }

    impl std::fmt::Display for Category {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.cli_name())
        }
    }
}
