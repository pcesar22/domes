//! Protocol Buffer generated types
//!
//! This module includes code generated from firmware/common/proto/*.proto
//! DO NOT manually define protocol types - they are generated by prost.
//!
//! To add new messages or modify existing ones:
//! 1. Edit firmware/common/proto/config.proto
//! 2. Run `cargo build` - prost will regenerate this code
//! 3. Update code that uses the types

/// Config protocol types (generated from config.proto)
pub mod config {
    include!(concat!(env!("OUT_DIR"), "/domes.config.rs"));

    impl Feature {
        /// Get user-friendly name for CLI display
        pub fn cli_name(&self) -> &'static str {
            match self {
                Feature::Unknown => "unknown",
                Feature::LedEffects => "led-effects",
                Feature::BleAdvertising => "ble",
                Feature::Wifi => "wifi",
                Feature::EspNow => "esp-now",
                Feature::Touch => "touch",
                Feature::Haptic => "haptic",
                Feature::Audio => "audio",
            }
        }

        /// Parse from CLI input string
        pub fn from_cli_name(s: &str) -> Option<Feature> {
            match s.to_lowercase().as_str() {
                "led-effects" | "led" | "leds" => Some(Feature::LedEffects),
                "ble" | "bluetooth" | "ble-advertising" => Some(Feature::BleAdvertising),
                "wifi" | "wi-fi" => Some(Feature::Wifi),
                "esp-now" | "espnow" => Some(Feature::EspNow),
                "touch" => Some(Feature::Touch),
                "haptic" | "haptics" => Some(Feature::Haptic),
                "audio" | "sound" => Some(Feature::Audio),
                _ => None,
            }
        }
    }

    impl std::fmt::Display for Feature {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.cli_name())
        }
    }

    impl std::str::FromStr for Feature {
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            Self::from_cli_name(s).ok_or_else(|| format!("Unknown feature: {}", s))
        }
    }

    impl RgbPattern {
        /// Get user-friendly name for CLI display
        pub fn cli_name(&self) -> &'static str {
            match self {
                RgbPattern::Off => "off",
                RgbPattern::Solid => "solid",
                RgbPattern::RainbowChase => "rainbow-chase",
                RgbPattern::CometTail => "comet-tail",
                RgbPattern::SparkleFire => "sparkle-fire",
            }
        }

        /// Parse from CLI input string
        pub fn from_cli_name(s: &str) -> Option<RgbPattern> {
            match s.to_lowercase().as_str() {
                "off" | "none" => Some(RgbPattern::Off),
                "solid" | "color" => Some(RgbPattern::Solid),
                "rainbow-chase" | "rainbow" => Some(RgbPattern::RainbowChase),
                "comet-tail" | "comet" => Some(RgbPattern::CometTail),
                "sparkle-fire" | "fire" | "sparkle" => Some(RgbPattern::SparkleFire),
                _ => None,
            }
        }
    }

    impl std::fmt::Display for RgbPattern {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.cli_name())
        }
    }

    impl std::str::FromStr for RgbPattern {
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            Self::from_cli_name(s).ok_or_else(|| format!("Unknown pattern: {}", s))
        }
    }
}
